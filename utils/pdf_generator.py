<<<<<<< HEAD
<<<<<<< HEAD

from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak, Image, HRFlowable
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_CENTER
from reportlab.lib.units import inch
import os
import re
import uuid

def clean_text(text):
    clean = re.sub(r"\s+", " ", text or "")
    clean = clean.replace("\\n", " ").replace("\n", " ").strip()
    return clean

def generate_pdf(content_dict, output_dir="generated_pdfs"):
    os.makedirs(output_dir, exist_ok=True)
    filename = f"{uuid.uuid4().hex}.pdf"
    filepath = os.path.join(output_dir, filename)

    doc = SimpleDocTemplate(filepath, pagesize=letter, title="Content365 Marketing Pack")
    styles = getSampleStyleSheet()
    custom_heading = ParagraphStyle(
        name="HeadingCenter",
        parent=styles["Heading1"],
        alignment=TA_CENTER,
        spaceAfter=10
    )
    footer_style = ParagraphStyle("Footer", fontSize=8, alignment=TA_CENTER, spaceBefore=20)

    flowables = []

    # Add logo if exists
    logo_path = "static/logo.png"
    if os.path.exists(logo_path):
        img = Image(logo_path, width=1.5*inch, height=1.5*inch)
        img.hAlign = "CENTER"
        flowables.append(img)
        flowables.append(Spacer(1, 0.2 * inch))

    def add_section(title, text, emoji="✨"):
        flowables.append(HRFlowable(width="100%", thickness=1, color="#cccccc"))
        flowables.append(Spacer(1, 0.1 * inch))
        flowables.append(Paragraph(f"{emoji} <b>{title}</b>", custom_heading))
        flowables.append(Spacer(1, 0.2 * inch))
        flowables.append(Paragraph(clean_text(text), styles["Normal"]))
        flowables.append(Spacer(1, 0.3 * inch))

    # Core Sections
    add_section("Blog Post", content_dict.get("blog_post", ""), "📝")
    add_section("Lead Magnet", content_dict.get("lead_magnet", ""), "📦")
    add_section("SEO Keywords", ", ".join(content_dict.get("seo_keywords", [])), "🔍")

    # Social Captions (platform grouped)
    social_captions = content_dict.get("social_captions", {})
    for platform, captions in social_captions.items():
        if captions:
            add_section(f"{platform} Captions", "\n\n".join(captions), "📣")

    # Hashtags (platform grouped)
    hashtags = content_dict.get("hashtags", {})
    for platform, tags in hashtags.items():
        if tags:
            add_section(f"{platform} Hashtags", " ".join(tags), "🏷️")

    # Premium Tips if included
    if "premium_tips" in content_dict:
        add_section("Pro Tips", "\n".join(content_dict["premium_tips"]), "💡")

    # Footer
    flowables.append(Spacer(1, 0.2 * inch))
    flowables.append(HRFlowable(width="100%", thickness=0.5, color="#dddddd"))
    flowables.append(Spacer(1, 0.1 * inch))
    flowables.append(Paragraph("Generated by Content365.xyz – © 2025", footer_style))

    doc.build(flowables)
    return filename
=======
# utils/pdf_generator.py
# -*- coding: utf-8 -*-
"""
Content365 Premium PDF Generator (v4.5)

Goal
- Eliminate hidden dependency on `micropip` or any runtime package installer.
- Work **with or without** ReportLab installed.
- Keep the same public API: `generate_pdf(gpt_response, output_path, brand_config=None, font_paths=None)`.
- Preserve clean branding, sectioning, and page numbers.

How it works
- If ReportLab is available, we use the professional Platypus build (full Unicode/emoji via DejaVu, colored header/footer, wrapped captions, etc.).
- If ReportLab is **not** available (or fonts are missing), we fall back to a **pure-stdlib PDF writer** that uses the built-in PDF font *Helvetica* (no emojis). This removes the need for `micropip` or any extra installs.

Limitations of fallback mode
- Uses core PDF font (Helvetica). Extended Unicode and emoji may not render.
- Colors are limited; we still draw simple header/footer bars in grayscale.

Expected input schema
{
  "blog": {
    "title": "...",
    "intro": "...",
    "bullets": ["...", "..."],
    "cta": "..."
  },
  "platforms": {
    "Instagram": {"caption": "...", "hashtags": ["#one", "#two"]},
    "LinkedIn":  {"caption": "...", "hashtags": ["#one", "#two"]}
  }
}

Brand config (optional)
{
  "brand_name": "Content365",
  "website": "content365.xyz",
  "logo_path": "assets/logo.png",
  "primary_color": (24/255, 119/255, 242/255),
  "footer_text": "© 2025 Content365 — Smart marketing packs"
}
"""

from __future__ import annotations
import os
from datetime import datetime
from typing import Dict, Any, List, Optional, Tuple
import re

# --- Optional dependency: ReportLab ---
try:
    from reportlab.lib.pagesizes import letter
    from reportlab.lib.units import inch
    from reportlab.pdfgen import canvas as rl_canvas
    from reportlab.pdfbase import pdfmetrics
    from reportlab.pdfbase.ttfonts import TTFont
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib import colors
    from reportlab.platypus import (
        SimpleDocTemplate,
        Paragraph,
        Spacer,
        Image,
        Table,
        TableStyle,
        ListFlowable,
        ListItem,
    )
    from reportlab.platypus.flowables import KeepTogether
    _HAS_REPORTLAB = True
except Exception:
    _HAS_REPORTLAB = False

# ========= Public API =========

def generate_pdf(
    gpt_response: Dict[str, Any],
    output_path: str = "output.pdf",
    brand_config: Optional[Dict[str, Any]] = None,
    font_paths: Optional[Tuple[str, str]] = None,
) -> str:
    """Build a branded, professional PDF for Content365.

    If ReportLab is installed, use the Pro builder; otherwise, use the
    stdlib fallback that requires no external packages.
    """
    brand = brand_config or {}

    if _HAS_REPORTLAB:
        try:
            return _generate_pdf_reportlab(gpt_response, output_path, brand, font_paths)
        except Exception:
            # Hard fallback if ReportLab path fails (e.g., missing fonts)
            return _generate_pdf_fallback(gpt_response, output_path, brand)
    else:
        return _generate_pdf_fallback(gpt_response, output_path, brand)


# =============================================================================
# ReportLab (Pro) implementation
# =============================================================================
DEFAULT_REGULAR = "assets/fonts/DejaVuSans.ttf"
DEFAULT_BOLD    = "assets/fonts/DejaVuSans-Bold.ttf"


def _register_fonts(regular_path: str, bold_path: str) -> bool:
    """Register DejaVu fonts if present. Returns True if registered, else False."""
    try:
        if not os.path.exists(regular_path) or not os.path.exists(bold_path):
            return False
        pdfmetrics.registerFont(TTFont("DejaVu", regular_path))
        pdfmetrics.registerFont(TTFont("DejaVu-Bold", bold_path))
        return True
    except Exception:
        return False


def _styles_reportlab(primary_color):
    styles = getSampleStyleSheet()
    # Base body
    base_font = "DejaVu" if "DejaVu" in pdfmetrics.getRegisteredFontNames() else "Helvetica"
    base_bold = "DejaVu-Bold" if "DejaVu-Bold" in pdfmetrics.getRegisteredFontNames() else "Helvetica-Bold"

    styles["Normal"].fontName = base_font
    styles["Normal"].fontSize = 11
    styles["Normal"].leading = 15

    def P(name, parent, **kw):
        st = ParagraphStyle(name, parent=parent)
        for k, v in kw.items():
            setattr(st, k, v)
        return st

    title = P(
        "C365Title", styles["Normal"], fontName=base_bold, fontSize=22, leading=26,
        textColor=primary_color, spaceAfter=10
    )
    h1 = P("C365H1", styles["Normal"], fontName=base_bold, fontSize=16, leading=20,
           spaceBefore=10, spaceAfter=6)
    h2 = P("C365H2", styles["Normal"], fontName=base_bold, fontSize=13.5, leading=18,
           spaceBefore=8, spaceAfter=4)
    small = P("C365Small", styles["Normal"], fontSize=9.5, leading=12)
    caption = P("C365Caption", styles["Normal"], fontSize=11, leading=16)
    bullet = P("C365Bullet", styles["Normal"], leftIndent=12, spaceBefore=2, spaceAfter=2)

    return {
        "title": title,
        "h1": h1,
        "h2": h2,
        "small": small,
        "caption": caption,
        "bullet": bullet,
        "normal": styles["Normal"],
        "base_font": base_font,
        "base_bold": base_bold,
    }

# --- Emoji stripping (consistent visual output; DejaVu lacks most emoji) ---
_EMOJI = re.compile(r'[\U0001F300-\U0001FAFF\U00002700-\U000027BF]')

def _strip_emoji(s: str) -> str:
    return _EMOJI.sub('', s or '')

def _safe_text(x: Optional[str]) -> str:
    if not x:
        return ""
    s = (x or "").replace("■", "•").replace("\t", " ").strip()
    # Always strip emoji (fonts typically won't render them nicely)
    try:
        s = _strip_emoji(s)
    except Exception:
        pass
    return s


def _mk_hashtags_para(hashtags: List[str], styles):
    clean = [h.strip() for h in (hashtags or []) if h and h.strip()]
    return Paragraph(", ".join(clean), styles["small"]) if clean else Paragraph("", styles["small"])


def _mk_bullet_list(items: List[str], styles) -> ListFlowable:
    # Use a filled circle if DejaVu is available; hyphen otherwise (max compatibility)
    registered = set(pdfmetrics.getRegisteredFontNames())
    has_dejavu = ("DejaVu" in registered) or ("DejaVu-Bold" in registered)
    bullet_char = "•" if has_dejavu else "-"

    bullets: List[ListItem] = []
    for it in items or []:
        p = Paragraph(_safe_text(it), styles["normal"])
        bullets.append(ListItem(p, leftIndent=6, bulletText=bullet_char))

    return ListFlowable(
        bullets,
        bulletType="bullet",
        bulletFontName=styles["base_font"],
        bulletFontSize=10,
    )


def _build_blog_section(gpt: Dict[str, Any], styles) -> List[Any]:
    story: List[Any] = []
    blog = gpt.get("blog", {}) or {}
    title = blog.get("title") or "Your Content Pack"
    intro = blog.get("intro") or ""
    bullets = blog.get("bullets") or []
    cta = blog.get("cta") or ""

    story.append(Spacer(1, 0.2 * inch))
    story.append(Paragraph(_safe_text(title), styles["title"]))
    if intro:
        story.append(Paragraph(_safe_text(intro), styles["normal"]))
        story.append(Spacer(1, 0.12 * inch))
    if bullets:
        story.append(Paragraph("Key Points", styles["h2"]))
        story.append(_mk_bullet_list(bullets, styles))
        story.append(Spacer(1, 0.12 * inch))
    if cta:
        story.append(Paragraph("CTA", styles["h2"]))
        story.append(Paragraph(_safe_text(cta), styles["normal"]))
    story.append(Spacer(1, 0.18 * inch))
    return story


def _build_platform_section(name: str, payload: Dict[str, Any], styles, primary_color) -> List[Any]:
    story: List[Any] = []
    cap = _safe_text((payload or {}).get("caption"))
    raw_hashtags = (payload or {}).get("hashtags") or []

    # Clean hashtags: trim, drop blanks, normalize leading '#', dedupe (preserve order)
    cleaned = []
    seen = set()
    for h in raw_hashtags:
        if not h:
            continue
        hh = ("#" + str(h).lstrip("#").strip()) if str(h).strip() else ""
        if hh and hh not in seen:
            seen.add(hh)
            cleaned.append(hh)

    # Section header bar
    header_data = [[f"{name}"]]
    header_table = Table(
        header_data,
        colWidths=[6.75 * inch],
        style=TableStyle([
            ("BACKGROUND", (0, 0), (-1, -1), primary_color),
            ("TEXTCOLOR", (0, 0), (-1, -1), colors.white),
            ("FONTNAME", (0, 0), (-1, -1), styles["base_bold"]),
            ("FONTSIZE", (0, 0), (-1, -1), 12),
            ("LEFTPADDING", (0, 0), (-1, -1), 8),
            ("RIGHTPADDING", (0, 0), (-1, -1), 8),
            ("TOPPADDING", (0, 0), (-1, -1), 4),
            ("BOTTOMPADDING", (0, 0), (-1, -1), 4),
        ])
    )
    story.append(header_table)
    story.append(Spacer(1, 0.06 * inch))

    if cap:
        story.append(Paragraph(cap, styles["caption"]))
        story.append(Spacer(1, 0.06 * inch))

    # Keep the "Hashtags" header + tags together (no orphaned header at page bottom)
    if cleaned:
        hashtags_block = [
            Paragraph("Hashtags", styles["h2"]),
            _mk_hashtags_para(cleaned, styles),
        ]
        story.append(KeepTogether(hashtags_block))

    story.append(Spacer(1, 0.16 * inch))
    return story


def _header_footer_funcs(brand: Dict[str, Any]):
    from reportlab.lib import colors as _c
    primary = brand.get("primary_color", _c.HexColor("#1877F2"))
    brand_name = brand.get("brand_name", "Content365")
    website = brand.get("website", "content365.xyz")
    footer_text = brand.get("footer_text", f"© {datetime.now().year} {brand_name} — content365.xyz")

    def draw_header(canvas: rl_canvas.Canvas, _doc):
        canvas.saveState()
        canvas.setFillColor(primary)
        canvas.rect(0, 10.55 * inch, 8.5 * inch, 0.45 * inch, fill=1, stroke=0)
        canvas.setFillColor(_c.white)
        canvas.setFont("Helvetica-Bold" if "DejaVu-Bold" not in pdfmetrics.getRegisteredFontNames() else "DejaVu-Bold", 12)
        canvas.drawString(0.75 * inch, 10.7 * inch, brand_name)
        canvas.setFont("Helvetica" if "DejaVu" not in pdfmetrics.getRegisteredFontNames() else "DejaVu", 9)
        canvas.drawRightString(8.0 * inch, 10.7 * inch, website)
        canvas.restoreState()

    def draw_footer(canvas: rl_canvas.Canvas, _doc):
        canvas.saveState()
        canvas.setFillColor(_c.HexColor("#F4F6F8"))
        canvas.rect(0, 0.25 * inch, 8.5 * inch, 0.35 * inch, fill=1, stroke=0)
        canvas.setFillColor(_c.black)
        canvas.setFont("Helvetica" if "DejaVu" not in pdfmetrics.getRegisteredFontNames() else "DejaVu", 9)
        canvas.drawString(0.75 * inch, 0.4 * inch, footer_text)
        canvas.restoreState()

    class _NumberedCanvas(rl_canvas.Canvas):
        def __init__(self, *a, **k):
            super().__init__(*a, **k)
            self._saved_page_states = []
        def showPage(self):
            self._saved_page_states.append(dict(self.__dict__))
            super().showPage()
        def save(self):
            total = len(self._saved_page_states)
            for state in self._saved_page_states:
                self.__dict__.update(state)
                self.setFont("Helvetica" if "DejaVu" not in pdfmetrics.getRegisteredFontNames() else "DejaVu", 9)
                self.drawRightString(8.0 * inch, 0.45 * inch, f"Page {self._pageNumber} of {total}")
                super().showPage()
            super().save()

    return draw_header, draw_footer, _NumberedCanvas

# Register DejaVu using env or defaults; return status for /health
def init_pdf_engine() -> dict:
    reg = os.getenv("PDF_FONT_REGULAR", DEFAULT_REGULAR)
    bold = os.getenv("PDF_FONT_BOLD", DEFAULT_BOLD)
    ok = False
    if _HAS_REPORTLAB:
        ok = _register_fonts(reg, bold)
    return {"ok": ok, "regular": reg, "bold": bold}

def init_pdf_engine() -> dict:
    """Register DejaVu using env or defaults; return status for /health."""
    reg = os.getenv("PDF_FONT_REGULAR", DEFAULT_REGULAR)
    bold = os.getenv("PDF_FONT_BOLD", DEFAULT_BOLD)
    ok = False
    if _HAS_REPORTLAB:
        ok = _register_fonts(reg, bold)
    return {"ok": ok, "regular": reg, "bold": bold}


def _generate_pdf_reportlab(
    gpt: Dict[str, Any],
    output_path: str,
    brand: Dict[str, Any],
    font_paths: Optional[Tuple[str, str]]
) -> str:
    # Fonts (optional)
    if font_paths and all(font_paths):
        _register_fonts(font_paths[0], font_paths[1])
    else:
        # Try default DejaVu if present; otherwise silently use Helvetica
        _register_fonts(DEFAULT_REGULAR, DEFAULT_BOLD)

    primary_color = brand.get("primary_color") or colors.HexColor("#1877F2")
    styles = _styles_reportlab(primary_color)
=======
# utils/pdf_generator.py
# -*- coding: utf-8 -*-
from __future__ import annotations

import os
import re
from typing import Dict, Any, List, Optional, Tuple

from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, Image, Table, TableStyle, Flowable, KeepTogether, PageBreak
)
    # NOTE: PageBreak imported for future use; not required by this build.
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfgen.canvas import Canvas
from reportlab.lib.utils import ImageReader
from reportlab.lib.enums import TA_LEFT

LOGO_MAX_W = 56   # points
LOGO_MAX_H = 56   # points
HEADER_GUTTER = 10

# =============================================================================
# Safe logo loader (prevents layout explosions)
# =============================================================================
def _safe_logo_image(path: str, max_w: int = LOGO_MAX_W, max_h: int = LOGO_MAX_H) -> Optional[Image]:
    if not path or not os.path.exists(path):
        return None
    try:
        reader = ImageReader(path)
        iw, ih = reader.getSize()
        if not iw or not ih:
            return None
        scale = min(max_w / float(iw), max_h / float(ih), 1.0)
        dw, dh = iw * scale, ih * scale
        img = Image(path, width=dw, height=dh, mask='auto')
        img.hAlign = "LEFT"
        return img
    except Exception:
        return None

# =============================================================================
# Font registration (DejaVu with safe fallbacks)
# =============================================================================
_FONT_REG_DONE = False
_BASE_FONT = "Helvetica"
_BASE_FONT_BOLD = "Helvetica-Bold"

def _try_register_ttf(name: str, path_candidates: List[str]) -> Optional[str]:
    for p in path_candidates:
        try:
            if not p or not os.path.exists(p):
                continue
            if os.path.getsize(p) < 1024:
                continue
            pdfmetrics.registerFont(TTFont(name, p))
            return name
        except Exception:
            continue
    return None

def _register_fonts_once():
    global _FONT_REG_DONE, _BASE_FONT, _BASE_FONT_BOLD
    if _FONT_REG_DONE:
        return
    dvn = _try_register_ttf("DejaVuSans", [
        "assets/fonts/DejaVuSans.ttf",
        "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
        "/Library/Fonts/DejaVuSans.ttf",
        "C:/Windows/Fonts/DejaVuSans.ttf",
    ])
    dvb = _try_register_ttf("DejaVuSans-Bold", [
        "assets/fonts/DejaVuSans-Bold.ttf",
        "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
        "/Library/Fonts/DejaVuSans-Bold.ttf",
        "C:/Windows/Fonts/DejaVuSans-Bold.ttf",
    ])
    if dvn and dvb:
        _BASE_FONT = "DejaVuSans"
        _BASE_FONT_BOLD = "DejaVuSans-Bold"
    _FONT_REG_DONE = True

# =============================================================================
# Helpers
# =============================================================================
PLATFORM_ORDER = ["Instagram", "LinkedIn", "TikTok", "Twitter", "Facebook"]

PLATFORM_COLORS: Dict[str, colors.Color] = {
    "Instagram": colors.Color(0.91, 0.33, 0.48),
    "LinkedIn":  colors.Color(0.00, 0.44, 0.71),
    "TikTok":    colors.Color(0.10, 0.10, 0.10),
    "Twitter":   colors.Color(0.11, 0.63, 0.95),
    "Facebook":  colors.Color(0.23, 0.35, 0.60),
}

def _norm_platform(p: str) -> str:
    if not p:
        return p
    pl = p.strip()
    if pl.lower() in {"x", "twitter"}:
        return "Twitter"
    return pl[:1].upper() + pl[1:].lower()

def _icon_path(platform: str) -> Optional[str]:
    base = "assets/icons"
    candidates = [
        os.path.join(base, f"{platform.lower()}.png"),
        os.path.join(base, f"{platform.capitalize()}.png"),
    ]
    for c in candidates:
        if os.path.exists(c):
            return c
    return None

# Hashtag helpers
_TAG_RX = re.compile(r"(?:#|\uFF03)([A-Za-z0-9_]+)")

def _extract_tags_from_text(text: str) -> List[str]:
    return [m.lower() for m in _TAG_RX.findall(text or "")]

def _dedupe_preserve(seq: List[str]) -> List[str]:
    seen = set()
    out: List[str] = []
    for t in seq:
        key = str(t).lstrip("#").strip().lower()
        if key and key not in seen:
            seen.add(key)
            out.append(key)
    return out

def _hashline(tags: List[str]) -> str:
    deduped = _dedupe_preserve(tags)
    cleaned = [f"#{str(t).lstrip('#').strip()}" for t in deduped if str(t).strip()]
    return " ".join(cleaned)

def _safe_text(x: Any) -> str:
    return "" if x is None else str(x)

# Emoji sanitization
_EMOJI_MAP = {
    "💡": "(tip)", "🚀": "(launch)", "✅": "(done)", "🔥": "(hot)", "🎯": "(goal)",
    "📣": "(announce)", "📈": "(growth)", "👇": "(below)", "🔗": "(link)", "✨": "*",
    "🧠": "(insight)", "⚡": "(fast)", "❓": "?", "⭐": "*", "🔍": "(search)",
}
_EMOJI_RX = re.compile(r"[\U0001F000-\U0001FAFF\U00002600-\U000026FF\U00002700-\U000027BF]", flags=re.UNICODE)

def _emoji_to_text(s: str) -> str:
    if not s:
        return ""
    return "".join(_EMOJI_MAP.get(ch, ch) for ch in s)

def _sanitize_for_pdf(s: str) -> str:
    t = (s or "").replace("\u00A0", " ")
    t = _emoji_to_text(t)
    t = _EMOJI_RX.sub("", t)
    return t

# Auto-link
_LINK_RX = re.compile(r'((?:https?://|www\.)\S+|[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})')

def _autolink(text: str) -> str:
    def _wrap(m):
        s = m.group(1)
        href = s
        if s.startswith('www.'):
            href = 'https://' + s
        if '@' in s and not s.startswith(('http://', 'https://', 'www.')):
            href = 'mailto:' + s
        return f'<a href="{href}">{s}</a>'
    return _LINK_RX.sub(_wrap, text or '')

# Inline hashtag handling
_INLINE_TAG_RX = re.compile(r'(?:#|\uFF03)[A-Za-z0-9_]+')

def _strip_inline_hashtags(text: str) -> str:
    if not text:
        return ""
    t = _INLINE_TAG_RX.sub("", text)
    return re.sub(r"\s{2,}", " ", t).strip()

def _fallback_hashtag_rules(platform_slug: str, tags: List[str], caption_text: str = "") -> List[str]:
    p = (_norm_platform(platform_slug) or "").strip().lower()
    caps = {"instagram": 12, "tiktok": 5, "linkedin": 3, "twitter": 2, "facebook": 3}
    max_n = caps.get(p, 8)
    cleaned = []
    for t in tags or []:
        tt = str(t).lstrip("#").strip().lower()
        if tt:
            cleaned.append(tt)
    cleaned = _dedupe_preserve(cleaned)
    if caption_text:
        inline = set(_extract_tags_from_text(caption_text))
        cleaned = [t for t in cleaned if t not in inline]
    return cleaned[:max_n]

def _apply_hashtag_rules(platform_slug: str, tags: List[str], caption_text: str = "") -> List[str]:
    try:
        from utils.hashtag_rules import enforce_hashtag_rules as _ehr
        return _ehr(platform_slug, tags, caption_text)
    except Exception:
        return _fallback_hashtag_rules(platform_slug, tags, caption_text)

# =============================================================================
# Flowables
# =============================================================================
class PlatformBanner(Flowable):
    def __init__(self, platform: str, avail_width: float, height: float = 28.0, radius: float = 6.0):
        super().__init__()
        self.platform = _norm_platform(platform)
        self.avail_width = float(avail_width or 0)
        self.height = float(height)
        self.radius = float(radius)
        self.padding_x = 10.0
        self.bg = PLATFORM_COLORS.get(self.platform, colors.Color(0.85, 0.85, 0.85))
        self._icon_reader: Optional[ImageReader] = None
        self._icon_w = self._icon_h = 0.0
        try:
            ip = _icon_path(self.platform)
            if ip:
                self._icon_reader = ImageReader(ip)
                iw, ih = self._icon_reader.getSize()
                target_h = max(0.0, self.height - 10.0)
                scale = min(target_h / float(ih or 1), 1.0)
                self._icon_w = (iw or 0) * scale
                self._icon_h = (ih or 0) * scale
        except Exception:
            self._icon_reader = None
        self.width = self.avail_width

    def wrap(self, availWidth, availHeight):
        self.width = min(self.avail_width or availWidth, availWidth)
        return self.width, self.height

    def draw(self):
        c = self.canv
        c.saveState()
        c.setFillColor(self.bg)
        c.setStrokeColor(self.bg)
        c.roundRect(0, 0, self.width, self.height, self.radius, stroke=0, fill=1)
        if self._icon_reader and self._icon_w > 0 and self._icon_h > 0:
            x = self.padding_x
            y = (self.height - self._icon_h) / 2.0
            try:
                c.drawImage(self._icon_reader, x, y, width=self._icon_w, height=self._icon_h, mask='auto', preserveAspectRatio=True, anchor='sw')
            except Exception:
                pass
        c.restoreState()

class CTACard(Flowable):
    def __init__(self, text: str, avail_width: float, style: ParagraphStyle):
        super().__init__()
        self.text = text or ""
        self.avail_width = float(avail_width or 0)
        self.style = style
        self.padding = 10
        self.radius = 8
        self.bg_color = colors.HexColor("#EEF6FF")
        self.border_color = colors.HexColor("#C7E1FF")
        self.border_width = 0.8
        self._para: Optional[Paragraph] = None
        self.width = self.avail_width
        self.height = 0

    def wrap(self, availWidth, availHeight):
        box_width = min(self.avail_width or availWidth, availWidth)
        inner_width = max(0, box_width - 2 * self.padding)
        self._para = Paragraph(self.text, self.style)
        pw, ph = self._para.wrap(inner_width, availHeight)
        self.width = box_width
        self.height = ph + 2 * self.padding
        return self.width, self.height

    def draw(self):
        c = self.canv
        c.saveState()
        c.setFillColor(self.bg_color)
        c.setStrokeColor(self.border_color)
        c.setLineWidth(self.border_width)
        c.roundRect(0, 0, self.width, self.height, self.radius, stroke=1, fill=1)
        c.translate(self.padding, self.padding)
        if self._para is not None:
            self._para.drawOn(c, 0, 0)
        c.restoreState()

# =============================================================================
# Styles
# =============================================================================
def _build_styles(brand_color: Tuple[float, float, float]) -> Dict[str, ParagraphStyle]:
    _register_fonts_once()
    base = getSampleStyleSheet()

    styles = {
        "H1": ParagraphStyle(
            "H1", parent=base["Heading1"], fontName=_BASE_FONT_BOLD, fontSize=20, leading=24,
            textColor=colors.black, spaceAfter=10
        ),
        "H2": ParagraphStyle(
            "H2", parent=base["Heading2"], fontName=_BASE_FONT_BOLD, fontSize=14, leading=18,
            textColor=colors.black, spaceBefore=12, spaceAfter=6
        ),
        "P": ParagraphStyle(
            "P", parent=base["BodyText"], fontName=_BASE_FONT, fontSize=11.2, leading=15.2,
            textColor=colors.black, spaceAfter=6
        ),
        "Bullet": ParagraphStyle(
            "Bullet", parent=base["BodyText"], fontName=_BASE_FONT, fontSize=11.2, leading=15.2,
            leftIndent=14, bulletIndent=4, spaceBefore=0, spaceAfter=4
        ),
        "Caption": ParagraphStyle(
            "Caption", parent=base["BodyText"], fontName=_BASE_FONT, fontSize=11.5, leading=15.5,
            textColor=colors.black, spaceBefore=6, spaceAfter=4
        ),
        "Hashtags": ParagraphStyle(
            "Hashtags", parent=base["BodyText"], fontName=_BASE_FONT, fontSize=9.7, leading=13.3,
            textColor=colors.Color(0.25, 0.25, 0.28), spaceAfter=10
        ),
        "CTA": ParagraphStyle(
            "CTA", parent=base["BodyText"], fontName=_BASE_FONT_BOLD, fontSize=11.5, leading=14.5,
            textColor=colors.Color(*brand_color)
        ),
        "Small": ParagraphStyle(
            "Small", parent=base["BodyText"], fontName=_BASE_FONT, fontSize=8.8, leading=11.5,
            textColor=colors.Color(0.28, 0.28, 0.3)
        ),
        # --- updated spacing below ---
        "Brand": ParagraphStyle(
            "Brand", parent=base["Heading2"], fontName=_BASE_FONT_BOLD,
            fontSize=13.5, leading=17.0, textColor=colors.black
        ),
        "BrandSub": ParagraphStyle(
            "BrandSub", parent=base["BodyText"], fontName=_BASE_FONT,
            fontSize=10.0, leading=13.5, textColor=colors.Color(0, 0, 0, 0.6),
            spaceBefore=1.5
        ),
    }
    return styles

def _resolve_logo_path(p: str) -> Optional[str]:
    if p and os.path.isabs(p) and os.path.exists(p):
        return p
    for c in [p or "", "assets/logo.png", "static/logo.png",
              os.path.join(os.getcwd(), "assets", "logo.png"),
              os.path.join(os.getcwd(), "static", "logo.png")]:
        if c and os.path.exists(c):
            return c
    return None

# =============================================================================
# Header/Footer
# =============================================================================
def _header_table(brand_config: Dict[str, Any], styles: Dict[str, ParagraphStyle], width: float):
    raw_logo = brand_config.get("logo_path") or ""
    logo_path = _resolve_logo_path(raw_logo)

    brand_name = brand_config.get("brand_name", "Content365")
    website = (brand_config.get("website") or "content365.xyz").strip()
    website_href = ("https://" + website) if website and not website.startswith(("http://", "https://")) else website

    # Logo (scaled safely) or tiny spacer
    logo_img = _safe_logo_image(logo_path, max_w=LOGO_MAX_W, max_h=LOGO_MAX_H) or Spacer(0.01, 0.01)

    # Right block: name + site
    name_para = Paragraph(brand_name, styles["Brand"])
    site_para = Paragraph(f'<a href="{website_href}">{website}</a>', styles["BrandSub"])
    right_tbl = Table([[name_para], [site_para]])
    right_tbl.setStyle(TableStyle([
        ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
        ("LEFTPADDING", (0, 0), (-1, -1), 0),
        ("RIGHTPADDING", (0, 0), (-1, -1), 0),
        ("TOPPADDING", (0, 0), (-1, -1), 0),
        ("BOTTOMPADDING", (0, 0), (-1, -1), 0),
    ]))

    # Layout math
    try:
        logo_w = getattr(logo_img, "drawWidth", LOGO_MAX_W)
        logo_h = getattr(logo_img, "drawHeight", LOGO_MAX_H)
    except Exception:
        logo_w, logo_h = LOGO_MAX_W, LOGO_MAX_H

    left_col_w  = max(logo_w, 0.6 * inch) + 6  # a bit of breathing room inside logo col
    spacer_w    = float(HEADER_GUTTER or 10)   # explicit gap between logo and text
    right_col_w = max(0, width - left_col_w - spacer_w)

    # ensure right_tbl wraps correctly at computed width
    right_tbl._argW = [right_col_w]  # type: ignore[attr-defined]

    row_h = max(logo_h, 0.6 * inch)

    # 3 columns: [logo] [gutter] [name+site]
    data = [[logo_img, "", right_tbl]]
    col_widths = [left_col_w, spacer_w, right_col_w]

    tbl = Table(data, colWidths=col_widths, rowHeights=[row_h], hAlign="LEFT")
    tbl.setStyle(TableStyle([
        ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
        ("LEFTPADDING", (0, 0), (-1, -1), 0),
        ("RIGHTPADDING", (0, 0), (-1, -1), 0),
        ("TOPPADDING", (0, 0), (-1, -1), 0),
        ("BOTTOMPADDING", (0, 0), (-1, -1), 0),
        ("BACKGROUND", (1, 0), (1, 0), colors.white),  # keep gutter transparent
    ]))
    return tbl

def _footer(canvas: Canvas, doc, brand_config: Dict[str, Any]):
    footer_text = brand_config.get("footer_text", "Generated by Content365.xyz — Create your own AI marketing packs in minutes.")
    canvas.saveState()
    canvas.setFont(_BASE_FONT, 8.5)
    canvas.setFillColor(colors.Color(0, 0, 0, 0.55))
    x = doc.leftMargin
    y = 0.5 * inch
    if footer_text:
        canvas.drawString(x, y, footer_text)
    try:
        canvas.drawRightString(doc.pagesize[0] - doc.rightMargin, y, f"Page {doc.page}")
    except Exception:
        pass
    canvas.restoreState()

# =============================================================================
# Normalizers for incoming payload (fixes X/Twitter key issues)
# =============================================================================
def _normalize_platform_map(d: Dict[str, Any]) -> Dict[str, Any]:
    """
    Returns a dict keyed by normalized platform names (Instagram, LinkedIn, TikTok, Twitter, Facebook).
    If duplicates normalize to the same key, later entries win.
    """
    out: Dict[str, Any] = {}
    for k, v in (d or {}).items():
        out[_norm_platform(k)] = v
    return out

# =============================================================================
# Main builder
# =============================================================================
def generate_pdf(payload: Dict[str, Any], output_path: str, brand_config: Optional[Dict[str, Any]] = None):
    brand_config = brand_config or {}
    brand_color = brand_config.get("primary_color", (0.12, 0.46, 0.95))

    _register_fonts_once()
    styles = _build_styles(brand_color)
>>>>>>> 5a37524 (Initial commit of Content365 project)

    doc = SimpleDocTemplate(
        output_path,
        pagesize=letter,
        leftMargin=0.75 * inch,
        rightMargin=0.75 * inch,
<<<<<<< HEAD
        topMargin=1.2 * inch,
        bottomMargin=0.8 * inch,
        title=brand.get("brand_name", "Content365") + " Pack",
        author=brand.get("brand_name", "Content365"),
    )

    story: List[Any] = []
    # Optional logo (soft-fail)
    lp = brand.get("logo_path")
    if lp and os.path.exists(lp):
        try:
            story.append(Image(lp, width=1.0 * inch, height=1.0 * inch, kind='proportional'))
            story.append(Spacer(1, 0.08 * inch))
        except Exception:
            story.append(Spacer(1, 0.01 * inch))

    # Blog
    story.extend(_build_blog_section(gpt, styles))

    # Platforms
    platforms = (gpt.get("platforms") or {})
    if platforms:
        story.append(Paragraph("Social Captions by Platform", styles["h1"]))
        story.append(Spacer(1, 0.04 * inch))
        for name, payload in platforms.items():
            story.extend(_build_platform_section(name, payload or {}, styles, primary_color))

    header_cb, footer_cb, CanvasClass = _header_footer_funcs(brand)
    doc.build(
        story,
        onFirstPage=lambda c, d: (header_cb(c, d), footer_cb(c, d)),
        onLaterPages=lambda c, d: (header_cb(c, d), footer_cb(c, d)),
        canvasmaker=CanvasClass,
    )
    return output_path


# =============================================================================
# Stdlib fallback implementation (no external deps)
# =============================================================================
# Very small PDF writer using core PDF features. Supports:
# - Header/footer bars (grayscale)
# - Title, paragraphs, bullets
# - Section headers for platforms
# - Simple wrapping & multipage

class _MiniPDF:
    PAGE_W = 612  # 8.5in * 72
    PAGE_H = 792  # 11in * 72
    MARGIN_L = 54  # 0.75in
    MARGIN_R = 54
    MARGIN_T = 86  # Leave room for header bar
    MARGIN_B = 58  # Leave room for footer bar
    LEADING = 14
    FONT_SIZE = 11

    def __init__(self):
        self.objects: List[bytes] = []
        self.pages: List[int] = []  # object indices for pages
        self.font_obj = self._add_object(self._font_object("F1", "Helvetica"))

    # --- Low-level object helpers ---
    def _add_object(self, body: bytes) -> int:
        self.objects.append(body)
        return len(self.objects)

    @staticmethod
    def _pdf_str(s: str) -> str:
        # Simple escape for parentheses and non-ascii replacement
        safe = ''.join((c if 32 <= ord(c) < 127 and c not in '()' else ('\\' + c if c in '()' else '?')) for c in s)
        return safe

    @staticmethod
    def _font_object(name: str, base: str) -> bytes:
        return f"<< /Type /Font /Subtype /Type1 /BaseFont /{base} /Name /{name} >>".encode()

    def _wrap(self, text: str, max_chars: int) -> List[str]:
        words = text.split()
        lines: List[str] = []
        cur = []
        cur_len = 0
        for w in words:
            add = (1 if cur else 0) + len(w)
            if cur_len + add <= max_chars:
                cur.append(w)
                cur_len += add
            else:
                lines.append(' '.join(cur))
                cur = [w]
                cur_len = len(w)
        if cur:
            lines.append(' '.join(cur))
        return lines or [""]

    def _begin_page(self, content_stream: bytes) -> int:
        # Content object
        content_obj = self._add_object(b"<< /Length %d >>\nstream\n" % len(content_stream) + content_stream + b"\nendstream")
        # Page object
        page_dict = (
            f"<< /Type /Page /Parent 0 0 R /MediaBox [0 0 {self.PAGE_W} {self.PAGE_H}] "
            f"/Resources << /Font << /F1 {self.font_obj} 0 R >> >> /Contents {content_obj} 0 R >>"
        ).encode()
        page_obj = self._add_object(page_dict)
        self.pages.append(page_obj)
        return page_obj

    def _header_footer_stream(self, page_num: int, page_count: int) -> str:
        # Simple gray header and footer bars + page number
        header = f"0.85 g 0 {self.PAGE_H-36} {self.PAGE_W} 24 re f 0 g\n"  # header bar
        footer = f"0.95 g 0 24 {self.PAGE_W} 18 re f 0 g\n"  # footer bar
        # Page X of Y (approx right align using char width ~0.5*font_size)
        label = f"Page {page_num} of {page_count}"
        est_w = int(len(label) * (self.FONT_SIZE * 0.5))
        x = self.PAGE_W - self.MARGIN_R - est_w
        y = 30
        text = (
            f"BT /F1 {self.FONT_SIZE} Tf {x} {y} Td ({self._pdf_str(label)}) Tj ET\n"
        )
        return header + footer + text

    def _text_block_stream(self, lines: List[str], start_x: int, start_y: int, leading: int) -> str:
        # Build a text block with T* line advances
        if not lines:
            return ""
        esc_lines = [self._pdf_str(l) for l in lines]
        parts = [f"BT /F1 {self.FONT_SIZE} Tf {start_x} {start_y} Td {leading} TL ({esc_lines[0]}) Tj"]
        for l in esc_lines[1:]:
            parts.append(f"T* ({l}) Tj")
        parts.append("ET\n")
        return "\n".join(parts)

    def add_page_from_sections(self, sections: List[Dict[str, Any]], page_num: int, page_count: int):
        # Build content stream string
        buf: List[str] = []
        buf.append(self._header_footer_stream(page_num, page_count))

        cursor_y = self.PAGE_H - self.MARGIN_T
        start_x = self.MARGIN_L
        max_width = self.PAGE_W - self.MARGIN_L - self.MARGIN_R
        # Approx chars per line based on 0.5*font_size pt per char
        max_chars = max(20, int(max_width / (self.FONT_SIZE * 0.5)))

        for sec in sections:
            kind = sec.get("kind")
            if kind == "gap":
                cursor_y -= sec.get("size", 10)
                continue
            if kind == "h1":
                # "Header" line (uppercase for fallback visual weight)
                text = (sec.get("text") or "").upper()
                for line in self._wrap(text, max_chars):
                    if cursor_y < self.MARGIN_B + 3 * self.LEADING:
                        break  # let outer paginate
                    buf.append(self._text_block_stream([line], start_x, cursor_y, self.LEADING))
                    cursor_y -= self.LEADING + 2
                cursor_y -= 4
                continue
            if kind == "para":
                for line in self._wrap(sec.get("text") or "", max_chars):
                    if cursor_y < self.MARGIN_B + 3 * self.LEADING:
                        break
                    buf.append(self._text_block_stream([line], start_x, cursor_y, self.LEADING))
                    cursor_y -= self.LEADING
                cursor_y -= 4
                continue
            if kind == "bullets":
                for item in sec.get("items") or []:
                    # Fallback engine uses ASCII hyphen for maximum compatibility
                    line = f"- {item}"
                    for sub in self._wrap(line, max_chars):
                        if cursor_y < self.MARGIN_B + 3 * self.LEADING:
                            break
                        buf.append(self._text_block_stream([sub], start_x, cursor_y, self.LEADING))
                        cursor_y -= self.LEADING
                cursor_y -= 4
                continue

        content = "".join(buf).encode("latin-1", errors="ignore")
        self._begin_page(content)

    def save(self, path: str):
        # Build Pages object
        kids = " ".join(f"{p} 0 R" for p in self.pages)
        pages_obj = self._add_object(f"<< /Type /Pages /Kids [{kids}] /Count {len(self.pages)} >>".encode())
        # Fix each page parent reference in object body (0 0 R -> pages_obj)
        fixed = []
        for obj in self.objects:
            fixed.append(obj.replace(b"/Parent 0 0 R", f"/Parent {pages_obj} 0 R".encode()))
        self.objects = fixed
        # Catalog
        catalog_obj = self._add_object(f"<< /Type /Catalog /Pages {pages_obj} 0 R >>".encode())

        # Write file with xref
        with open(path, "wb") as f:
            f.write(b"%PDF-1.4\n%\xe2\xe3\xcf\xd3\n")
            offsets = [0]
            for i, obj in enumerate(self.objects, start=1):
                offsets.append(f.tell())
                f.write(f"{i} 0 obj\n".encode())
                f.write(obj)
                f.write(b"\nendobj\n")
            xref_pos = f.tell()
            f.write(f"xref\n0 {len(self.objects)+1}\n".encode())
            f.write(b"0000000000 65535 f \n")
            for off in offsets[1:]:
                f.write(f"{off:010d} 00000 n \n".encode())
            f.write(b"trailer\n")
            f.write(f"<< /Size {len(self.objects)+1} /Root {catalog_obj} 0 R >>\n".encode())
            f.write(b"startxref\n")
            f.write(f"{xref_pos}\n".encode())
            f.write(b"%%EOF")


def _sections_from_gpt(gpt: Dict[str, Any], brand: Dict[str, Any]) -> List[Dict[str, Any]]:
    sections: List[Dict[str, Any]] = []
    brand_name = brand.get("brand_name", "Content365")
    website = brand.get("website", "content365.xyz")

    # Title
    title = (gpt.get("blog", {}) or {}).get("title") or f"{brand_name} Content Pack"
    sections += [{"kind": "gap", "size": 16}, {"kind": "h1", "text": title}, {"kind": "gap", "size": 6}]

    # Intro
    intro = (gpt.get("blog", {}) or {}).get("intro") or ""
    if intro:
        sections += [{"kind": "para", "text": intro}, {"kind": "gap", "size": 6}]

    # Bullets
    bullets = (gpt.get("blog", {}) or {}).get("bullets") or []
    if bullets:
        sections += [{"kind": "h1", "text": "Key Points"}, {"kind": "bullets", "items": bullets}, {"kind": "gap", "size": 6}]

    # CTA
    cta = (gpt.get("blog", {}) or {}).get("cta") or ""
    if cta:
        sections += [{"kind": "h1", "text": "CTA"}, {"kind": "para", "text": cta}, {"kind": "gap", "size": 10}]

    # Platforms
    platforms = (gpt.get("platforms") or {})
    if platforms:
        sections += [{"kind": "h1", "text": "Social Captions by Platform"}, {"kind": "gap", "size": 6}]
        for name, payload in platforms.items():
            sections += [
                {"kind": "h1", "text": str(name)},
                {"kind": "para", "text": (payload or {}).get("caption") or ""},
            ]
            hts = (payload or {}).get("hashtags") or []
            if hts:
                sections += [
                    {"kind": "para", "text": "Hashtags: " + ", ".join([h for h in hts if h])},
                ]
            sections.append({"kind": "gap", "size": 10})
    return sections


def _generate_pdf_fallback(gpt: Dict[str, Any], output_path: str, brand: Dict[str, Any]) -> str:
    sections = _sections_from_gpt(gpt, brand)
    # Simple pagination: chunk sections across pages based on rough line budget
    pdf = _MiniPDF()

    # Convert sections into pages by estimating line usage
    pages: List[List[Dict[str, Any]]] = []
    current: List[Dict[str, Any]] = []
    line_budget = int((pdf.PAGE_H - pdf.MARGIN_T - pdf.MARGIN_B) / pdf.LEADING)
    used = 0

    def _estimate_lines(sec: Dict[str, Any]) -> int:
        if sec["kind"] == "gap":
            return max(1, sec.get("size", 10) // pdf.LEADING)
        if sec["kind"] == "h1":
            return 2
        if sec["kind"] == "para":
            # rough wrap estimate
            max_chars = max(20, int((pdf.PAGE_W - pdf.MARGIN_L - pdf.MARGIN_R) / (pdf.FONT_SIZE * 0.5)))
            text = (sec.get("text") or "")
            return max(1, (len(text) // max_chars) + 1)
        if sec["kind"] == "bullets":
            count = len(sec.get("items") or [])
            return max(1, count)
        return 1

    for sec in sections:
        need = _estimate_lines(sec)
        if used + need > line_budget and current:
            pages.append(current)
            current = []
            used = 0
        current.append(sec)
        used += need
    if current:
        pages.append(current)

    # Render
    for i, pg in enumerate(pages, start=1):
        pdf.add_page_from_sections(pg, i, len(pages))

    pdf.save(output_path)
    return output_path


def get_pdf_engine_info() -> dict:
    """Return info about which engine will be used at runtime."""
    info = {"mode": "fallback", "reportlab": False, "dejavu": False}
    try:
        if _HAS_REPORTLAB:
            info["reportlab"] = True
            info["mode"] = "reportlab"
            try:
                from reportlab.pdfbase import pdfmetrics as _pm
                names = set(_pm.getRegisteredFontNames())
                info["dejavu"] = ("DejaVu" in names) or ("DejaVu-Bold" in names)
            except Exception:
                info["dejavu"] = False
    except Exception:
        pass
    return info


# ======== Self-tests ========
if __name__ == "__main__":
    # 1) Basic
    sample = {
        "blog": {
            "title": "💸 Gen-Z Personal Finance Guide",
            "intro": "A quick, practical playbook to budget smarter, build a starter emergency fund, and invest early.",
            "bullets": [
                "Track cashflow weekly with the 50/30/20 rule.",
                "Automate savings on payday (even $25/week compounds).",
                "Start with a low-fee index fund; avoid hype cycles.",
            ],
            "cta": "Ready to grow faster? Get your free starter template at content365.xyz →",
        },
        "platforms": {
            "Instagram": {
                "caption": "Money moves for your 20s: keep it simple, keep it automatic.",
                "hashtags": ["#MoneyTips", "#GenZFinance", "#Budgeting", "#Investing", "#PersonalFinance"],
            },
            "LinkedIn": {
                "caption": "Three small changes that improve cashflow in 30 days (and make your future self grateful).",
                "hashtags": ["#Career", "#Finance", "#Productivity"],
            },
        },
    }
    brand = {
        "brand_name": "Content365",
        "website": "content365.xyz",
        "logo_path": "assets/logo.png",
        "primary_color": (0.12, 0.46, 0.95),
        "footer_text": "© 2025 Content365 — Smart marketing packs",
    }
    print("Writing test_basic.pdf …")
    generate_pdf(sample, output_path="test_basic.pdf", brand_config=brand)

    # 2) Missing fields
    missing = {"blog": {"title": "Starter Pack"}, "platforms": {}}
    print("Writing test_missing_fields.pdf …")
    generate_pdf(missing, output_path="test_missing_fields.pdf", brand_config=brand)

    # 3) Wrapping & multipage
    long_caption = (
        "This is a very long caption intended to test line wrapping and fallback pagination in the minimal PDF "
        "builder. It should wrap across multiple lines without crashing or overlapping the footer region."
    )
    wrapping = {
        "blog": {"title": "Wrapping Test", "intro": long_caption, "bullets": ["One", "Two", "Three"]},
        "platforms": {
            "Twitter": {"caption": long_caption * 5, "hashtags": ["#One", "#Two", "#Three", "#Four"]}
        },
    }
    print("Writing test_wrapping.pdf …")
    generate_pdf(wrapping, output_path="test_wrapping.pdf", brand_config=brand)
    print("Done.")
>>>>>>> 2ed0c2a (chore: wire Gemini provider + provider_router)
=======
        topMargin=0.75 * inch,
        bottomMargin=0.75 * inch,
        title=brand_config.get("brand_name", "Content365")
    )

    story: List[Any] = []
    story.append(_header_table(brand_config, styles, doc.width))
    story.append(Spacer(1, 10))

    # Blog
    blog = (payload.get("blog") or {})
    headline = _sanitize_for_pdf(_safe_text(blog.get("headline") or "Your Content Pack"))
    intro = _safe_text(blog.get("intro"))
    body_list = blog.get("body") or []
    bullets = blog.get("bullets") or []
    cta = _safe_text(blog.get("cta"))

    story.append(Paragraph(headline, styles["H1"]))
    if intro:
        story.append(Paragraph(_autolink(_sanitize_for_pdf(intro)), styles["P"]))
        story.append(Spacer(1, 2))
    if body_list:
        for p in body_list:
            s = _safe_text(p)
            if s:
                story.append(Paragraph(_autolink(_sanitize_for_pdf(s)), styles["P"]))
        story.append(Spacer(1, 2))
    if bullets:
        for b in bullets:
            s = _safe_text(b)
            story.append(Paragraph("• " + _autolink(_sanitize_for_pdf(s)), styles["Bullet"]))
        story.append(Spacer(1, 2))
    if cta:
        story.append(CTACard(_autolink(_sanitize_for_pdf(cta)), doc.width, styles["CTA"]))
        story.append(Spacer(1, 12))

    # Divider
    story.append(_thin_divider(doc.width))
    story.append(Spacer(1, 6))

    # Social: normalize maps so 'x'/'X' keys feed 'Twitter'
    captions_in = _normalize_platform_map(payload.get("captions") or {})
    hashtags_in = _normalize_platform_map(payload.get("hashtags") or {})

    platforms_seen = list(captions_in.keys())
    ordered = [p for p in PLATFORM_ORDER if p in platforms_seen] + [p for p in platforms_seen if p not in PLATFORM_ORDER]

    # Fallback caption seed (so a platform never renders totally empty)
    fallback_seed = headline

    for plat in ordered:
        cap_block = captions_in.get(plat) or {}
        tag_list = hashtags_in.get(plat) or []
        parts = _platform_block(plat, cap_block, tag_list, styles, doc.width, fallback_seed)
        if parts:
            story += parts
            story.append(Spacer(1, 10))

    def _on_page(canvas: Canvas, doc_obj):
        try:
            if getattr(doc_obj, "page", 0) == 1:
                canvas.setAuthor(brand_config.get("brand_name", "Content365"))
                canvas.setTitle(headline)
                canvas.setSubject("Social content pack")
        except Exception:
            pass
        _footer(canvas, doc_obj, brand_config)

    doc.build(story, onFirstPage=_on_page, onLaterPages=_on_page)

# =============================================================================
# Pieces
# =============================================================================
def _thin_divider(width: float) -> Table:
    t = Table([[""]], colWidths=[width], rowHeights=[0.6])
    t.setStyle(TableStyle([
        ("LINEBEFORE", (0, 0), (-1, -1), 0, colors.white),
        ("LINEAFTER",  (0, 0), (-1, -1), 0, colors.white),
        ("TOPPADDING", (0, 0), (-1, -1), 0),
        ("BOTTOMPADDING", (0, 0), (-1, -1), 0),
        ("BACKGROUND", (0, 0), (-1, -1), colors.Color(0, 0, 0, 0.08)),
    ]))
    return t

def _platform_block(platform: str, caption_block: Any, tag_list: List[str],
                    styles: Dict[str, ParagraphStyle], width: float, fallback_text: str = "") -> List[Any]:
    plat = _norm_platform(platform)
    parts: List[Any] = []

    # Banner
    parts.append(PlatformBanner(plat, width, height=28))
    parts.append(Spacer(1, 4))

    # Caption text (string or dict with 'text' key)
    if isinstance(caption_block, dict):
        text = caption_block.get("text") or caption_block.get("caption") or ""
    else:
        text = caption_block or ""
    text = _sanitize_for_pdf(_safe_text(text))

    # Inline tags -> collect & strip
    inline_from_caption = set(_extract_tags_from_text(text))
    caption_clean = _strip_inline_hashtags(text)

    # Merge explicit tags with inline
    merged_tags: List[str] = list(tag_list or [])
    merged_tags += [f"#{t}" for t in inline_from_caption if t]

    # Apply platform-specific rules
    clamped_tags = _apply_hashtag_rules(plat, merged_tags, caption_clean)

    # Fallback caption if truly empty after stripping
    if not caption_clean and not clamped_tags:
        caption_clean = _sanitize_for_pdf(_safe_text(fallback_text))

    # If still nothing, skip this platform block entirely
    if not caption_clean and not clamped_tags:
        return []

    if caption_clean:
        parts.append(Paragraph(_autolink(caption_clean), styles["Caption"]))
    if clamped_tags:
        parts.append(Paragraph(_hashline(clamped_tags), styles["Hashtags"]))

    return parts
>>>>>>> 5a37524 (Initial commit of Content365 project)
