<<<<<<< HEAD

from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak, Image, HRFlowable
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_CENTER
from reportlab.lib.units import inch
import os
import re
import uuid

def clean_text(text):
    clean = re.sub(r"\s+", " ", text or "")
    clean = clean.replace("\\n", " ").replace("\n", " ").strip()
    return clean

def generate_pdf(content_dict, output_dir="generated_pdfs"):
    os.makedirs(output_dir, exist_ok=True)
    filename = f"{uuid.uuid4().hex}.pdf"
    filepath = os.path.join(output_dir, filename)

    doc = SimpleDocTemplate(filepath, pagesize=letter, title="Content365 Marketing Pack")
    styles = getSampleStyleSheet()
    custom_heading = ParagraphStyle(
        name="HeadingCenter",
        parent=styles["Heading1"],
        alignment=TA_CENTER,
        spaceAfter=10
    )
    footer_style = ParagraphStyle("Footer", fontSize=8, alignment=TA_CENTER, spaceBefore=20)

    flowables = []

    # Add logo if exists
    logo_path = "static/logo.png"
    if os.path.exists(logo_path):
        img = Image(logo_path, width=1.5*inch, height=1.5*inch)
        img.hAlign = "CENTER"
        flowables.append(img)
        flowables.append(Spacer(1, 0.2 * inch))

    def add_section(title, text, emoji="✨"):
        flowables.append(HRFlowable(width="100%", thickness=1, color="#cccccc"))
        flowables.append(Spacer(1, 0.1 * inch))
        flowables.append(Paragraph(f"{emoji} <b>{title}</b>", custom_heading))
        flowables.append(Spacer(1, 0.2 * inch))
        flowables.append(Paragraph(clean_text(text), styles["Normal"]))
        flowables.append(Spacer(1, 0.3 * inch))

    # Core Sections
    add_section("Blog Post", content_dict.get("blog_post", ""), "📝")
    add_section("Lead Magnet", content_dict.get("lead_magnet", ""), "📦")
    add_section("SEO Keywords", ", ".join(content_dict.get("seo_keywords", [])), "🔍")

    # Social Captions (platform grouped)
    social_captions = content_dict.get("social_captions", {})
    for platform, captions in social_captions.items():
        if captions:
            add_section(f"{platform} Captions", "\n\n".join(captions), "📣")

    # Hashtags (platform grouped)
    hashtags = content_dict.get("hashtags", {})
    for platform, tags in hashtags.items():
        if tags:
            add_section(f"{platform} Hashtags", " ".join(tags), "🏷️")

    # Premium Tips if included
    if "premium_tips" in content_dict:
        add_section("Pro Tips", "\n".join(content_dict["premium_tips"]), "💡")

    # Footer
    flowables.append(Spacer(1, 0.2 * inch))
    flowables.append(HRFlowable(width="100%", thickness=0.5, color="#dddddd"))
    flowables.append(Spacer(1, 0.1 * inch))
    flowables.append(Paragraph("Generated by Content365.xyz – © 2025", footer_style))

    doc.build(flowables)
    return filename

    doc = SimpleDocTemplate(
        output_path,
        pagesize=letter,
        leftMargin=0.75 * inch,
        rightMargin=0.75 * inch,
        topMargin=1.2 * inch,
        bottomMargin=0.8 * inch,
        title=brand.get("brand_name", "Content365") + " Pack",
        author=brand.get("brand_name", "Content365"),
    )

    story: List[Any] = []
    # Optional logo (soft-fail)
    lp = brand.get("logo_path")
    if lp and os.path.exists(lp):
        try:
            story.append(Image(lp, width=1.0 * inch, height=1.0 * inch, kind='proportional'))
            story.append(Spacer(1, 0.08 * inch))
        except Exception:
            story.append(Spacer(1, 0.01 * inch))

    # Blog
    story.extend(_build_blog_section(gpt, styles))

    # Platforms
    platforms = (gpt.get("platforms") or {})
    if platforms:
        story.append(Paragraph("Social Captions by Platform", styles["h1"]))
        story.append(Spacer(1, 0.04 * inch))
        for name, payload in platforms.items():
            story.extend(_build_platform_section(name, payload or {}, styles, primary_color))

    header_cb, footer_cb, CanvasClass = _header_footer_funcs(brand)
    doc.build(
        story,
        onFirstPage=lambda c, d: (header_cb(c, d), footer_cb(c, d)),
        onLaterPages=lambda c, d: (header_cb(c, d), footer_cb(c, d)),
        canvasmaker=CanvasClass,
    )
    return output_path


# =============================================================================
# Stdlib fallback implementation (no external deps)
# =============================================================================
# Very small PDF writer using core PDF features. Supports:
# - Header/footer bars (grayscale)
# - Title, paragraphs, bullets
# - Section headers for platforms
# - Simple wrapping & multipage

class _MiniPDF:
    PAGE_W = 612  # 8.5in * 72
    PAGE_H = 792  # 11in * 72
    MARGIN_L = 54  # 0.75in
    MARGIN_R = 54
    MARGIN_T = 86  # Leave room for header bar
    MARGIN_B = 58  # Leave room for footer bar
    LEADING = 14
    FONT_SIZE = 11

    def __init__(self):
        self.objects: List[bytes] = []
        self.pages: List[int] = []  # object indices for pages
        self.font_obj = self._add_object(self._font_object("F1", "Helvetica"))

    # --- Low-level object helpers ---
    def _add_object(self, body: bytes) -> int:
        self.objects.append(body)
        return len(self.objects)

    @staticmethod
    def _pdf_str(s: str) -> str:
        # Simple escape for parentheses and non-ascii replacement
        safe = ''.join((c if 32 <= ord(c) < 127 and c not in '()' else ('\\' + c if c in '()' else '?')) for c in s)
        return safe

    @staticmethod
    def _font_object(name: str, base: str) -> bytes:
        return f"<< /Type /Font /Subtype /Type1 /BaseFont /{base} /Name /{name} >>".encode()

    def _wrap(self, text: str, max_chars: int) -> List[str]:
        words = text.split()
        lines: List[str] = []
        cur = []
        cur_len = 0
        for w in words:
            add = (1 if cur else 0) + len(w)
            if cur_len + add <= max_chars:
                cur.append(w)
                cur_len += add
            else:
                lines.append(' '.join(cur))
                cur = [w]
                cur_len = len(w)
        if cur:
            lines.append(' '.join(cur))
        return lines or [""]

    def _begin_page(self, content_stream: bytes) -> int:
        # Content object
        content_obj = self._add_object(b"<< /Length %d >>\nstream\n" % len(content_stream) + content_stream + b"\nendstream")
        # Page object
        page_dict = (
            f"<< /Type /Page /Parent 0 0 R /MediaBox [0 0 {self.PAGE_W} {self.PAGE_H}] "
            f"/Resources << /Font << /F1 {self.font_obj} 0 R >> >> /Contents {content_obj} 0 R >>"
        ).encode()
        page_obj = self._add_object(page_dict)
        self.pages.append(page_obj)
        return page_obj

    def _header_footer_stream(self, page_num: int, page_count: int) -> str:
        # Simple gray header and footer bars + page number
        header = f"0.85 g 0 {self.PAGE_H-36} {self.PAGE_W} 24 re f 0 g\n"  # header bar
        footer = f"0.95 g 0 24 {self.PAGE_W} 18 re f 0 g\n"  # footer bar
        # Page X of Y (approx right align using char width ~0.5*font_size)
        label = f"Page {page_num} of {page_count}"
        est_w = int(len(label) * (self.FONT_SIZE * 0.5))
        x = self.PAGE_W - self.MARGIN_R - est_w
        y = 30
        text = (
            f"BT /F1 {self.FONT_SIZE} Tf {x} {y} Td ({self._pdf_str(label)}) Tj ET\n"
        )
        return header + footer + text

    def _text_block_stream(self, lines: List[str], start_x: int, start_y: int, leading: int) -> str:
        # Build a text block with T* line advances
        if not lines:
            return ""
        esc_lines = [self._pdf_str(l) for l in lines]
        parts = [f"BT /F1 {self.FONT_SIZE} Tf {start_x} {start_y} Td {leading} TL ({esc_lines[0]}) Tj"]
        for l in esc_lines[1:]:
            parts.append(f"T* ({l}) Tj")
        parts.append("ET\n")
        return "\n".join(parts)

    def add_page_from_sections(self, sections: List[Dict[str, Any]], page_num: int, page_count: int):
        # Build content stream string
        buf: List[str] = []
        buf.append(self._header_footer_stream(page_num, page_count))

        cursor_y = self.PAGE_H - self.MARGIN_T
        start_x = self.MARGIN_L
        max_width = self.PAGE_W - self.MARGIN_L - self.MARGIN_R
        # Approx chars per line based on 0.5*font_size pt per char
        max_chars = max(20, int(max_width / (self.FONT_SIZE * 0.5)))

        for sec in sections:
            kind = sec.get("kind")
            if kind == "gap":
                cursor_y -= sec.get("size", 10)
                continue
            if kind == "h1":
                # "Header" line (uppercase for fallback visual weight)
                text = (sec.get("text") or "").upper()
                for line in self._wrap(text, max_chars):
                    if cursor_y < self.MARGIN_B + 3 * self.LEADING:
                        break  # let outer paginate
                    buf.append(self._text_block_stream([line], start_x, cursor_y, self.LEADING))
                    cursor_y -= self.LEADING + 2
                cursor_y -= 4
                continue
            if kind == "para":
                for line in self._wrap(sec.get("text") or "", max_chars):
                    if cursor_y < self.MARGIN_B + 3 * self.LEADING:
                        break
                    buf.append(self._text_block_stream([line], start_x, cursor_y, self.LEADING))
                    cursor_y -= self.LEADING
                cursor_y -= 4
                continue
            if kind == "bullets":
                for item in sec.get("items") or []:
                    # Fallback engine uses ASCII hyphen for maximum compatibility
                    line = f"- {item}"
                    for sub in self._wrap(line, max_chars):
                        if cursor_y < self.MARGIN_B + 3 * self.LEADING:
                            break
                        buf.append(self._text_block_stream([sub], start_x, cursor_y, self.LEADING))
                        cursor_y -= self.LEADING
                cursor_y -= 4
                continue

        content = "".join(buf).encode("latin-1", errors="ignore")
        self._begin_page(content)

    def save(self, path: str):
        # Build Pages object
        kids = " ".join(f"{p} 0 R" for p in self.pages)
        pages_obj = self._add_object(f"<< /Type /Pages /Kids [{kids}] /Count {len(self.pages)} >>".encode())
        # Fix each page parent reference in object body (0 0 R -> pages_obj)
        fixed = []
        for obj in self.objects:
            fixed.append(obj.replace(b"/Parent 0 0 R", f"/Parent {pages_obj} 0 R".encode()))
        self.objects = fixed
        # Catalog
        catalog_obj = self._add_object(f"<< /Type /Catalog /Pages {pages_obj} 0 R >>".encode())

        # Write file with xref
        with open(path, "wb") as f:
            f.write(b"%PDF-1.4\n%\xe2\xe3\xcf\xd3\n")
            offsets = [0]
            for i, obj in enumerate(self.objects, start=1):
                offsets.append(f.tell())
                f.write(f"{i} 0 obj\n".encode())
                f.write(obj)
                f.write(b"\nendobj\n")
            xref_pos = f.tell()
            f.write(f"xref\n0 {len(self.objects)+1}\n".encode())
            f.write(b"0000000000 65535 f \n")
            for off in offsets[1:]:
                f.write(f"{off:010d} 00000 n \n".encode())
            f.write(b"trailer\n")
            f.write(f"<< /Size {len(self.objects)+1} /Root {catalog_obj} 0 R >>\n".encode())
            f.write(b"startxref\n")
            f.write(f"{xref_pos}\n".encode())
            f.write(b"%%EOF")


def _sections_from_gpt(gpt: Dict[str, Any], brand: Dict[str, Any]) -> List[Dict[str, Any]]:
    sections: List[Dict[str, Any]] = []
    brand_name = brand.get("brand_name", "Content365")
    website = brand.get("website", "content365.xyz")

    # Title
    title = (gpt.get("blog", {}) or {}).get("title") or f"{brand_name} Content Pack"
    sections += [{"kind": "gap", "size": 16}, {"kind": "h1", "text": title}, {"kind": "gap", "size": 6}]

    # Intro
    intro = (gpt.get("blog", {}) or {}).get("intro") or ""
    if intro:
        sections += [{"kind": "para", "text": intro}, {"kind": "gap", "size": 6}]

    # Bullets
    bullets = (gpt.get("blog", {}) or {}).get("bullets") or []
    if bullets:
        sections += [{"kind": "h1", "text": "Key Points"}, {"kind": "bullets", "items": bullets}, {"kind": "gap", "size": 6}]

    # CTA
    cta = (gpt.get("blog", {}) or {}).get("cta") or ""
    if cta:
        sections += [{"kind": "h1", "text": "CTA"}, {"kind": "para", "text": cta}, {"kind": "gap", "size": 10}]

    # Platforms
    platforms = (gpt.get("platforms") or {})
    if platforms:
        sections += [{"kind": "h1", "text": "Social Captions by Platform"}, {"kind": "gap", "size": 6}]
        for name, payload in platforms.items():
            sections += [
                {"kind": "h1", "text": str(name)},
                {"kind": "para", "text": (payload or {}).get("caption") or ""},
            ]
            hts = (payload or {}).get("hashtags") or []
            if hts:
                sections += [
                    {"kind": "para", "text": "Hashtags: " + ", ".join([h for h in hts if h])},
                ]
            sections.append({"kind": "gap", "size": 10})
    return sections


def _generate_pdf_fallback(gpt: Dict[str, Any], output_path: str, brand: Dict[str, Any]) -> str:
    sections = _sections_from_gpt(gpt, brand)
    # Simple pagination: chunk sections across pages based on rough line budget
    pdf = _MiniPDF()

    # Convert sections into pages by estimating line usage
    pages: List[List[Dict[str, Any]]] = []
    current: List[Dict[str, Any]] = []
    line_budget = int((pdf.PAGE_H - pdf.MARGIN_T - pdf.MARGIN_B) / pdf.LEADING)
    used = 0

    def _estimate_lines(sec: Dict[str, Any]) -> int:
        if sec["kind"] == "gap":
            return max(1, sec.get("size", 10) // pdf.LEADING)
        if sec["kind"] == "h1":
            return 2
        if sec["kind"] == "para":
            # rough wrap estimate
            max_chars = max(20, int((pdf.PAGE_W - pdf.MARGIN_L - pdf.MARGIN_R) / (pdf.FONT_SIZE * 0.5)))
            text = (sec.get("text") or "")
            return max(1, (len(text) // max_chars) + 1)
        if sec["kind"] == "bullets":
            count = len(sec.get("items") or [])
            return max(1, count)
        return 1

    for sec in sections:
        need = _estimate_lines(sec)
        if used + need > line_budget and current:
            pages.append(current)
            current = []
            used = 0
        current.append(sec)
        used += need
    if current:
        pages.append(current)

    # Render
    for i, pg in enumerate(pages, start=1):
        pdf.add_page_from_sections(pg, i, len(pages))

    pdf.save(output_path)
    return output_path


def get_pdf_engine_info() -> dict:
    """Return info about which engine will be used at runtime."""
    info = {"mode": "fallback", "reportlab": False, "dejavu": False}
    try:
        if _HAS_REPORTLAB:
            info["reportlab"] = True
            info["mode"] = "reportlab"
            try:
                from reportlab.pdfbase import pdfmetrics as _pm
                names = set(_pm.getRegisteredFontNames())
                info["dejavu"] = ("DejaVu" in names) or ("DejaVu-Bold" in names)
            except Exception:
                info["dejavu"] = False
    except Exception:
        pass
    return info


# ======== Self-tests ========
if __name__ == "__main__":
    # 1) Basic
    sample = {
        "blog": {
            "title": "💸 Gen-Z Personal Finance Guide",
            "intro": "A quick, practical playbook to budget smarter, build a starter emergency fund, and invest early.",
            "bullets": [
                "Track cashflow weekly with the 50/30/20 rule.",
                "Automate savings on payday (even $25/week compounds).",
                "Start with a low-fee index fund; avoid hype cycles.",
            ],
            "cta": "Ready to grow faster? Get your free starter template at content365.xyz →",
        },
        "platforms": {
            "Instagram": {
                "caption": "Money moves for your 20s: keep it simple, keep it automatic.",
                "hashtags": ["#MoneyTips", "#GenZFinance", "#Budgeting", "#Investing", "#PersonalFinance"],
            },
            "LinkedIn": {
                "caption": "Three small changes that improve cashflow in 30 days (and make your future self grateful).",
                "hashtags": ["#Career", "#Finance", "#Productivity"],
            },
        },
    }
    brand = {
        "brand_name": "Content365",
        "website": "content365.xyz",
        "logo_path": "assets/logo.png",
        "primary_color": (0.12, 0.46, 0.95),
        "footer_text": "© 2025 Content365 — Smart marketing packs",
    }
    print("Writing test_basic.pdf …")
    generate_pdf(sample, output_path="test_basic.pdf", brand_config=brand)

    # 2) Missing fields
    missing = {"blog": {"title": "Starter Pack"}, "platforms": {}}
    print("Writing test_missing_fields.pdf …")
    generate_pdf(missing, output_path="test_missing_fields.pdf", brand_config=brand)

    # 3) Wrapping & multipage
    long_caption = (
        "This is a very long caption intended to test line wrapping and fallback pagination in the minimal PDF "
        "builder. It should wrap across multiple lines without crashing or overlapping the footer region."
    )
    wrapping = {
        "blog": {"title": "Wrapping Test", "intro": long_caption, "bullets": ["One", "Two", "Three"]},
        "platforms": {
            "Twitter": {"caption": long_caption * 5, "hashtags": ["#One", "#Two", "#Three", "#Four"]}
        },
    }
    print("Writing test_wrapping.pdf …")
    generate_pdf(wrapping, output_path="test_wrapping.pdf", brand_config=brand)
    print("Done.")
>>>>>>> 2ed0c2a (chore: wire Gemini provider + provider_router) 5a37524 (Initial commit of Content365 project)

